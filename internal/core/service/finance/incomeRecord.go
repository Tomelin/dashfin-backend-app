package finance

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	entity_common "github.com/Tomelin/dashfin-backend-app/internal/core/entity/common"
	entity_finance "github.com/Tomelin/dashfin-backend-app/internal/core/entity/finance"
	"github.com/Tomelin/dashfin-backend-app/pkg/message_queue"
)

// IncomeRecordService provides business logic for income records.
type IncomeRecordService struct {
	Repo entity_finance.IncomeRecordRepositoryInterface
	mq   message_queue.MessageQueue
}

// InitializeIncomeRecordService creates a new IncomeRecordService.
func InitializeIncomeRecordService(repo entity_finance.IncomeRecordRepositoryInterface, mq message_queue.MessageQueue) (entity_finance.IncomeRecordServiceInterface, error) {
	if repo == nil {
		return nil, errors.New("repository is nil for IncomeRecordService")
	}
	if mq == nil {
		return nil, errors.New("message queue is nil for IncomeRecordService")
	}
	return &IncomeRecordService{
		Repo: repo,
		mq:   mq,
	}, nil
}

// CreateIncomeRecord handles the creation of a new income record.
// It also manages recurring income records.
func (s *IncomeRecordService) CreateIncomeRecord(ctx context.Context, data *entity_finance.IncomeRecord) (*entity_finance.IncomeRecord, error) {
	if data == nil {
		return nil, errors.New("income record data is nil")
	}

	// UserID should be set by the handler from context before calling this service method.
	userIDFromCtx := ctx.Value("UserID")
	if userIDFromCtx == nil {
		return nil, errors.New("userID not found in context")
	}
	userIDStr, ok := userIDFromCtx.(string)
	if !ok {
		return nil, errors.New("userID in context is not a string")
	}
	if userIDStr == "" {
		return nil, errors.New("userID in context is empty")
	}
	data.UserID = userIDStr

	if err := data.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	data.CreatedAt = time.Now()
	data.UpdatedAt = time.Now()

	// Handle recurring income
	if data.IsRecurring && data.RecurrenceCount != nil && *data.RecurrenceCount > 0 {
		var firstCreatedRecord *entity_finance.IncomeRecord
		var err error

		originalReceiptDateStr := data.ReceiptDate
		originalReceiptDate, parseErr := time.Parse("2006-01-02", originalReceiptDateStr)
		if parseErr != nil {
			return nil, fmt.Errorf("invalid receiptDate format for recurrence: %w", parseErr)
		}

		for i := 0; i < *data.RecurrenceCount; i++ {
			currentRecord := *data // Create a copy for each recurrence
			currentRecord.RecurrenceNumber = i + 1

			if i > 0 { // For subsequent recurrences, adjust the date
				newReceiptDate := originalReceiptDate.AddDate(0, i, 0) // Add i months
				currentRecord.ReceiptDate = newReceiptDate.Format("2006-01-02")
				currentRecord.ID = "" // Ensure new ID is generated by repository
				currentRecord.CreatedAt = time.Now()
				currentRecord.UpdatedAt = time.Now()
			}

			// Validate each potentially modified record (especially date)
			// Note: Validate() might be too broad if only date changes, but safe.
			if errVal := currentRecord.Validate(); errVal != nil {
				// Log this error, decide if we should stop or skip this one occurrence
				// For now, let's stop and return error for simplicity
				return nil, fmt.Errorf("validation failed for recurring instance %d: %w", i+1, errVal)
			}

			created, repoErr := s.Repo.CreateIncomeRecord(ctx, &currentRecord)
			if repoErr != nil {
				// If one fails, should we rollback previous or just return error?
				// For now, return error. Consider transactional behavior for production.
				return nil, fmt.Errorf("failed to create recurring income record (instance %d): %w", i+1, repoErr)
			}
			if i == 0 {
				firstCreatedRecord = created
			}
		}
		s.publishMessage(ctx, mq_rk_income_create, firstCreatedRecord, "", entity_common.ActionCreate)
		return firstCreatedRecord, err // Returns the first created record of the series
	}

	// For non-recurring income
	s.publishMessage(ctx, mq_rk_income_create, data, "", entity_common.ActionCreate)
	return s.Repo.CreateIncomeRecord(ctx, data)
}

// GetIncomeRecordByID retrieves an income record by its ID, ensuring user authorization.
func (s *IncomeRecordService) GetIncomeRecordByID(ctx context.Context, id string) (*entity_finance.IncomeRecord, error) {
	if strings.TrimSpace(id) == "" {
		return nil, errors.New("id is empty")
	}

	userIDFromCtx := ctx.Value("UserID")
	if userIDFromCtx == nil {
		return nil, errors.New("userID not found in context")
	}
	userIDStr, ok := userIDFromCtx.(string)
	if !ok {
		return nil, errors.New("userID in context is not a string")
	}
	if userIDStr == "" {
		return nil, errors.New("userID in context is empty")
	}

	record, err := s.Repo.GetIncomeRecordByID(ctx, id)
	if err != nil {
		// Repository handles "not found"
		return nil, err
	}

	// Service layer authorization check
	if record.UserID != userIDStr {
		// Log this attempt, could be a security issue or bug
		// log.Printf("Authorization failed (service): User %v attempted to access record %s owned by %s", userIDFromCtx, id, record.UserID)
		return nil, errors.New("income record not found or access denied") // Generic message for security
	}

	return record, nil
}

// GetIncomeRecords retrieves income records based on filters for the authenticated user.
func (s *IncomeRecordService) GetIncomeRecords(ctx context.Context, params *entity_finance.GetIncomeRecordsQueryParameters) ([]entity_finance.IncomeRecord, error) {
	userIDFromCtx := ctx.Value("UserID")
	if userIDFromCtx == nil {
		return nil, errors.New("userID not found in context for GetIncomeRecords")
	}
	userIDStr, ok := userIDFromCtx.(string)
	if !ok {
		return nil, errors.New("userID in context is not a string")
	}
	if userIDStr == "" {
		return nil, errors.New("userID in context is empty for GetIncomeRecords")
	}

	// Ensure the query is scoped to the user from the context, not the parameter if they differ or if userID param is for other purposes.
	// For this method, the `userID` parameter in the function signature seems redundant if we always use UserID from context.
	// Let's assume the userID parameter in the signature is intended to be the authenticated user's ID.
	// If `userID` param could be different (e.g. admin use), then authorization logic would be more complex.
	// For now, enforce that the provided userID matches the one in context if both are present.
	if params.UserID != "" && params.UserID != userIDStr {
		// This indicates a potential misuse of the service method or an attempt to access unauthorized data.
		// log.Printf("Warning: Mismatch between UserID in context (%s) and UserID parameter (%s) in GetIncomeRecords.", userIDFromCtx.(string), userID)
		return nil, errors.New("user ID parameter mismatch with authenticated user")
	}

	queryParams := &entity_finance.GetIncomeRecordsQueryParameters{
		UserID: userIDStr, // Always use UserID from context for security
	}

	if params.Description != nil && strings.TrimSpace(*params.Description) != "" {
		queryParams.Description = params.Description
	}
	if params.StartDate != nil && strings.TrimSpace(*params.StartDate) != "" {
		queryParams.StartDate = params.StartDate
	}
	if params.EndDate != nil && strings.TrimSpace(*params.EndDate) != "" {
		queryParams.EndDate = params.EndDate
	}
	if params.SortKey != nil && strings.TrimSpace(*params.SortKey) != "" {
		queryParams.SortKey = params.SortKey
	}
	if params.SortDirection != nil && strings.TrimSpace(*params.SortDirection) != "" {
		// Basic validation, repository will do more specific validation
		lowerSortDirection := strings.ToLower(*params.SortDirection)
		if lowerSortDirection == "asc" || lowerSortDirection == "desc" {
			queryParams.SortDirection = &lowerSortDirection
		} else {
			return nil, errors.New("invalid sortDirection value, must be 'asc' or 'desc'")
		}
	}

	if err := queryParams.Validate(); err != nil {
		return nil, fmt.Errorf("invalid query parameters for GetIncomeRecords: %w", err)
	}

	records, err := s.Repo.GetIncomeRecords(ctx, queryParams)
	if err != nil {
		// Repository might return specific "not found" errors or empty slices.
		// Service layer can decide if "no records found" is an error or just an empty result.
		// Based on ExpenseRecordService, it seems we propagate the error.
		return nil, err
	}
	// if len(records) == 0 { // This check might be redundant if repo returns specific "not found" error or handles empty slice
	// 	return []entity_finance.IncomeRecord{}, nil // Or return error as per API contract
	// }
	return records, nil
}

// UpdateIncomeRecord handles updating an existing income record.
func (s *IncomeRecordService) UpdateIncomeRecord(ctx context.Context, id string, data *entity_finance.IncomeRecord) (*entity_finance.IncomeRecord, error) {
	if strings.TrimSpace(id) == "" {
		return nil, errors.New("id is empty for update")
	}
	if data == nil {
		return nil, errors.New("income record data for update is nil")
	}

	userIDFromCtx := ctx.Value("UserID")
	if userIDFromCtx == nil {
		return nil, errors.New("userID not found in context for update")
	}
	userIDStr, ok := userIDFromCtx.(string)
	if !ok {
		return nil, errors.New("userID in context is not a string")
	}
	if userIDStr == "" {
		return nil, errors.New("userID in context is empty for update")
	}

	// Ensure the UserID in the payload matches the one from context for consistency.
	// The repository will perform the definitive ownership check against the stored record.
	data.UserID = userIDStr

	// Validate data before sending to repository
	if err := data.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed for update: %w", err)
	}

	// Retrieve existing record to ensure it belongs to the user (service-level check)
	// The repository also does this, but it's good practice for service to be aware.
	existingRecord, err := s.Repo.GetIncomeRecordByID(ctx, id)
	if err != nil {
		return nil, err // Handles "not found" from repository
	}

	if existingRecord.UserID != userIDStr {
		// log.Printf("Authorization failed for update (service): User %v attempted to update record %s owned by %s", userIDFromCtx, id, existingRecord.UserID)
		return nil, errors.New("income record not found or access denied for update")
	}

	// Preserve original CreatedAt, ID. Update UpdatedAt.
	data.ID = existingRecord.ID // Ensure ID from path is used, not from payload if different
	data.CreatedAt = existingRecord.CreatedAt
	data.UpdatedAt = time.Now()

	result, err := s.Repo.UpdateIncomeRecord(ctx, id, data)
	if err != nil {
		return nil, err
	}

	s.publishMessage(ctx, mq_rk_income_delete, data, "", entity_common.ActionDelete)
	s.publishMessage(ctx, mq_rk_income_create, result, "", entity_common.ActionCreate)

	return result, err
}

// DeleteIncomeRecord handles deleting an income record.
func (s *IncomeRecordService) DeleteIncomeRecord(ctx context.Context, id string) error {
	if strings.TrimSpace(id) == "" {
		return errors.New("id is empty for delete")
	}

	userIDFromCtx := ctx.Value("UserID")
	if userIDFromCtx == nil {
		return errors.New("userID not found in context for delete")
	}
	userIDStr, ok := userIDFromCtx.(string)
	if !ok {
		return errors.New("userID in context is not a string")
	}
	if userIDStr == "" {
		return errors.New("userID in context is empty for delete")
	}

	// Service-level check: Retrieve the record first to ensure it belongs to the user.
	// The repository also performs this check, but it's a good pattern for the service.
	recordToVerify, err := s.Repo.GetIncomeRecordByID(ctx, id)
	if err != nil {
		return err // Handles "not found" from repository, which is fine.
	}

	if recordToVerify.UserID != userIDStr {
		// log.Printf("Authorization failed for delete (service): User %v attempted to delete record %s owned by %s", userIDFromCtx, id, recordToVerify.UserID)
		return errors.New("income record not found or access denied for delete")
	}

	err = s.Repo.DeleteIncomeRecord(ctx, id)
	if err != nil {
		return err
	}

	s.publishMessage(ctx, mq_rk_income_delete, recordToVerify, "", entity_common.ActionDelete)

	return err
}

func (s *IncomeRecordService) publishMessage(ctx context.Context, routeKey string, income *entity_finance.IncomeRecord, trace string, action entity_common.ActionEvent) error {

	if income == nil {
		return errors.New("income record is nil")
	}

	i := entity_finance.IncomeRecordEvent{
		Action: action,
		Data:   *income,
	}
	body, _ := json.Marshal(i)

	return s.mq.PublisherWithRouteKey(mq_exchange, routeKey, body, trace)
}
